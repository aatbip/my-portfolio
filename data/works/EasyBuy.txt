id:03
heading:Easy Buy
github_link:github.com/aatbip/easy-buy
live_link:
short_description:A boilerplate for e-commerce along with a custom authentication/authorization API, and an approach to use Redux-Toolkit in NextJS by syncing up state changes in both client and server side, built with NextJS and Express.
description:I wanted to explore NextJS and its core features for a while, so I started making Easy Buy. This project has a well implemented custom JWT role based authentication login, and a way to sync up client and server side state changes using Redux-Toolkit with NextJS.
<ul><li>Handling authentication is hard for all kinds of applications! In the case of Next.js where we need to handle both client-side and server-side authentication at times, it can take more effort. If you're using 3rd party auth providers then NextAuth library is the best option. However, in this project, I have injected auth APIs that are custom designed in Express. So the best approach to handle client-side authentication is in useEffect and server-side authentication in getServerSideProps.</li><li> Writing the logic for protected routes in Next.js is all about implementing middleware. We can write functions for the individual route in the middleware.ts file that Next.js will run before the page pointed by that route executes and renders.</li><li>Using Redux in Next.js can be tricky. Since the states can change on both client-side and server-side, we need to make sure the states are in sync and there exists a single source of truth. next-redux-wrapper is a library that can make our work easier. However, this project uses a different approach. An action called "rehydrate" is created which can be dispatched from within useEffect that helps sync up the states. I realized that this approach can mess up things in a large project so setting up next-redux-wrapper can be a better option too.</li><li>One of the best ways to write reusable components logic in react/next apps is to create Higher Order Components (HOCs). This project makes use of a custom HOC for form validation. Well, writing your own form validation logic can get tedious and you may better wanna use dedicated libraries instead.</li></ul> 