id:01
heading:My Portfolio
github_link:github.com/aatbip/my-portfolio
frontend_link:
backend_link:
live_link:anantabipal.dev
short_description:Making this portfolio website was a leisure. It was a continuous process of thinking what I really want, and taking virtuous technical decisions to not face an arduous development experience. Let's talk about some of them!   
images:
description:I wanted to keep my site as simple as possible while doing few things in a new way. I didn't want to maintain any database or CMS for managing my contents. I wanted to make the process of building and deployment of my site completely invisible to me — as soon as I push a commit to the repository, I wanted changes to be live. I also wanted to have a better experience while adding new contents — just write the content in a plain text file and the code taking care of the rest. 
<h3><b>NextJS</b><h3>
I love React but it is a bit painful to start a new project from scratch with it. React doesn't offer out-of-the-box solution for routing, SSR, and data fetching. NextJS made it easier to generating static assets, handling routes, and fetching data from within the project's root directory. 
<h3><b>Content Management</b></h3>
I didn't want to manage a database or CMS. My goal was to put all my contents in the project's directory itself written in ".txt" file. I wanted to have the experience of writing new contents as if I am writing on google doc. Writing the contents in YAML or MD was an option, but like I said, I wanted a feeling of plain text. Hence, there were challenges in achiving all these and NextJS came handy even in this part.  

As I was avoiding database, I had to store all the contents in the project directory. Node.js internal modules can't run in the browser and it would have been difficult to use modules like <code>path</code> and <code>fs</code> to interact with the file system. I wrote a few lines of code that can receive the file and do some logic to convert it into json. Then, using <code>getServerSideProps()</code> which runs only in the server made it possible to access the file system's contents converted into json just ready to be used in my component. 
<h3><b>The Keyboard</b></h3> 
I wanted to avoid interaction through mouse in my site but I was worried if this decision would make user experience in mobile devices a major flaw. Because in mobile devices, focusing on input box makes the mobile's native keyboard to pop out, it would hide half of the display. The solution was to create a custom Keyboard component that will only be shown in the mobile devices. By using <code>inputMode="none"</code> and <code>autoFocus={false}</code> in the input element I can stop the native mobile's keyboard from poping out. Then, react-device-detect library helped me to detect mobile devices to show the Keyboard component only in the mobile devices. 
<h3><b>React Hydration Error</b></h3>
If you have worked with server side rendering on React (or using NextJS) then you probably might have faced this error <code>Error: Hydration failed because the initial UI does not match what was rendered on the server.</code> 
Hydration is the technique used by React to compare the React tree that was rendered for the first time when app loads, with the React tree that is pre-rendered on the server. If they're not in sync with eachother then we get the hydration error. In sync with eachother simply means that the tree that was rendered in the server should match the tree during the first render.
We have to make sure to tackle the hydration error programatically. In this app there are two scenarios where I had to handle hydration error. I want to share one of it here. I was rendering an extra component by detecting the mobile device. React-device-detect library provides a handy prop <code>isMobile</code> that can be used to render something only if mobile device is detected <code>{isMobile && do something}</code>. But at the time of SSG, the server can't interprete <code>isMobile</code> because server doesn't have any access to the window or other browser related objects. So the block of code after <code>{isMobile && ...(i will render...)}</code> gets pre-rendered on the server. 
Now here comes the issue. When the same code runs in the client side, browser can interprete it and doesn't render the block of code after <code>{isMobile && ...(i won't render)...}</code>. So, the pre-rendered React tree and the newly rendered React tree doesn't sync up with each other and we get the hydration error. 
To fix this, we can create a state <code>const [render, setRender] = useState(false)</code>. Then, <code>if (!render) return null</code>, return null from the component if render is still false. Now inside the useEffect we can change the state of render to true <code>useEffect(() => setRender(true), [])</code>. Since useEffect() only runs on the client side, any code below will not get returned and that won't cause mismatch between React trees. 
Now this method only fits fine for some scenarios but there are many other methods according to the scenarios. In this case I was returning null if <code>render</code> is false because the component I was rendering doesn't have any data in it and it is not necessary to statically generate the contents of the components that doesn't have any contents.
<h3><b>Building and Deployment</b></h3>
As said before, I wanted to make building and deployment part of my site completely invisible to me. I used Netlify to handle that for me. Netlify can automate the building also auto installing the required plugins for building a NextJS app. It can easily integrate with GitHub and all new commits will automatically get deployed without me having to worry. 
<h3><b>Final Words</b></h3>
There are few architectural scopes that can be made better, but as of now I am quite satisfied with this.
  